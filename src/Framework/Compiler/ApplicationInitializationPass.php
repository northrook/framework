<?php

declare(strict_types=1);

namespace Core\Framework\Compiler;

use Core\Action\Toast;
use Core\Symfony\Console\Output;
use Core\Symfony\DependencyInjection\CompilerPass;
use Support\{Filesystem, Normalize, Reflect, Time};
use JetBrains\PhpStorm\Language;
use Symfony\Component\DependencyInjection\ContainerBuilder;
use Override, Exception, ReflectionClassConstant;
use Symfony\Component\Finder\Finder;
use LogicException;
use SplFileInfo;
use InvalidArgumentException;

final class ApplicationInitializationPass extends CompilerPass
{
    protected readonly string $bundleDirectory;

    protected readonly string $defaultsDirectory;

    public function __construct( string $__DIR__ )
    {
        $this->bundleDirectory   = \dirname( $__DIR__ );
        $this->defaultsDirectory = Normalize::path( "{$this->bundleDirectory}/app-defaults" );
    }

    #[Override]
    public function compile( ContainerBuilder $container ) : void
    {
        $this->path( 'config/packages/debug.yaml' )->remove();

        $this->normalizePathParameters();

        $this->initializeDefaultConfiguration();

        // $this->cacheConfiguration();
        // $this->securityConfiguration();

        // $this
        //     ->generateToastMeta()
        //     ->generateAppKernel( true )
        //     ->generatePublicIndex(
        //         true,
        //         'Do not edit this file.',
        //         'It will be regenerated when the Container is built or updated.',
        //     )
        //     ->generateControllerRouteConfig()
        //     ->createConfigServices()
        //     ->configurePreload()
        //     ->coreControllerRoutes();
    }

    protected function initializeDefaultConfiguration() : void
    {
        $app_defaults = new Finder();

        $app_defaults->files()->in( $this->defaultsDirectory )->name( ['*.php', '*.yaml'] );

        foreach ( $app_defaults as $default ) {
            $project_path = $this->getProjectPath( $default );

            if ( $this->skipExistingFile( $project_path ) ) {
                $this->console->info( 'Skipping existing file: '.$project_path );

                continue;
            }

            $config = $this->createPhpConfig( $default->getRealPath() );

            Filesystem::save( $project_path, $config );
        }
    }

    protected function createPhpConfig( string $source, bool $canEdit = true ) : string
    {
        $contents = \file_get_contents( $source );

        if ( ! $contents ) {
            throw new LogicException( 'Could not read file: '.$source );
        }

        $config = \trim( \substr( $contents, \strlen( '<?php' ) ) );

        $config = (string) \preg_replace( '#^\h*?/\*\*.*?@noinspection.*?\*/\s\R*#ms', '', $config );

        $dateTime = Time::now();

        $name            = \pathinfo( $source, PATHINFO_BASENAME );
        $timestamp       = $dateTime->unixTimestamp;
        $date            = $dateTime->format( 'Y-m-d H:i:s e' );
        $generator       = __CLASS__;
        $contentDataHash = $this::hashConfiguration( $contents );

        $comment = $canEdit ? <<<'EOL'
            You may edit this file as you please.
                       
               This file will be re-generated by the Container Builder
               if this comment or the file itself is removed.
            EOL
                : 'Do not edit it manually.';

        $config = <<<PHP
            <?php
            
            /*--------------------------------------------------------{$timestamp}-
            
               Name      : {$name}
               Generated : {$date}
            
               This file is generated by:
               {$generator}.
            
               {$comment}
            
            -#{$contentDataHash}#------------------------------------------------*/
            
            {$config}
            PHP;

        $config = \rtrim( $config ).PHP_EOL;

        $config = (string) \preg_replace( '#^\h+$#m', '', $config );

        return \str_replace( PHP_EOL, "\n", $config );
    }

    /**
     * Takes in a PHP `$string`.
     *
     * Trims:
     * - opening `<?php`
     * - all comments
     * - whitespace
     *
     * Returns a `xxh3` hash of the `$string`.
     *
     * @param string $string
     *
     * @return string
     */
    public static function hashConfiguration(
        #[Language( 'PHP' )]
        string $string,
    ) : string {
        if ( \str_starts_with( $string, '<?php' ) ) {
            $string = \trim( \substr( $string, \strlen( '<?php' ) ) );
        }

        $removeComments = [
            '#^\h*?/\*\*.*?\*/\s\R*#ms', // PHP block comments
            '#\h*?//.+\R*#m',            // Single line comments
            '#\h*?/\*.*?\*/\R*#ms',      // Block comments
            "#\s+#",                     // Whitespace
        ];

        $string = (string) \preg_replace( $removeComments, ' ', $string );

        $string = \trim( $string );

        return \hash( 'xxh3', $string );
    }

    protected function generateToastMeta() : self
    {
        $reflect = Reflect::class( Toast::class );

        $byConstants = $reflect->getConstants( ReflectionClassConstant::IS_PUBLIC );

        $status = \array_filter( $byConstants, static fn( $value ) => \is_string( $value ) );

        $toastStatusTypes = "'".\implode( "', '", $status )."'";

        $this->createPhpFile(
            '.phpstorm.meta.php/.toast_action.meta.php',
            <<<PHP
                <?php 
                    
                namespace PHPSTORM_META;
                    
                expectedArguments(
                    \Core\Action\Toast::__invoke(),
                    0,
                    {$toastStatusTypes}
                );
                PHP,
            true,
        );

        return $this;
    }

    protected function generateControllerRouteConfig( bool $override = false ) : self
    {
        $this->path( 'config/routes.yaml' )->remove();
        $this->path( 'config/routes.php' )->remove();

        $routes = [
            'app.controller' => [
                'resource' => [
                    'path'      => '../../src/Controller/',
                    'namespace' => 'App\Controller',
                ],
                'type' => 'attribute',
            ],
        ];

        $this->createYamlFile( 'config/routes/app.yaml', $routes, true );

        return $this;
    }

    protected function coreControllerRoutes() : self
    {
        // TODO : Ensure we set the controller attribute namespaces correctly

        $routes = [
            'core.controller' => [
                'resource' => [
                    'path'      => '@CoreBundle/src/Controller',
                    'namespace' => 'Core\Controller',
                ],
                'type' => 'attribute',
            ],
        ];

        $this->createYamlFile( 'config/routes/core.yaml', $routes, true );

        return $this;
    }

    private function normalizePathParameters() : void
    {
        foreach ( $this->parameterBag->all() as $key => $value ) {
            // Only parse prefixed keys
            if ( \str_starts_with( $key, 'dir.' ) || \str_starts_with( $key, 'path.' ) ) {
                // Skip pure-placeholders
                if ( \str_starts_with( $value, '%' ) && \str_ends_with( $value, '%' ) ) {
                    continue;
                }

                // Normalize and report
                try {
                    $value = Normalize::path( $value );
                    $this->parameterBag->set( $key, $value );
                }
                catch ( Exception $e ) {
                    $message = Output::format( Output::MARKER, 'error' )."{$key} : {$e->getMessage()}";
                    Output::printLine( $message );
                }
            }
        }
    }

    private function getProjectPath( string|SplFileInfo $path ) : string
    {
        if ( \is_string( $path ) ) {
            $path = new SplFileInfo( $path );
        }

        $relativePath = \substr( $path->getRealPath(), \strlen( $this->defaultsDirectory ) );

        return Normalize::path( [$this->projectDirectory, $relativePath] );
    }

    private function skipExistingFile( string $path ) : bool
    {
        // Always create if no file is found
        if ( ! Filesystem::exists( $path ) ) {
            return false;
        }

        // Ensure
        if ( ! \is_readable( $path ) ) {
            $setPermissions = \chmod( $path, 0755 );
            if ( ! $setPermissions ) {
                $this->console->error( 'Skipping existing file due to read permissions error: '.$path );
                return false;
            }
        }

        // Always skip existing .yaml configs
        if ( \pathinfo( $path, PATHINFO_EXTENSION ) === 'yaml' ) {
            $this->console->info( 'Skipping existing [yaml] file: '.$path );
            return false;
        }

        $stream = \fopen( $path, 'r' );

        if ( false === $stream ) {
            $message = __CLASS__.' is unable to open file : '.$path;
            throw new InvalidArgumentException( $message );
        }

        $lineCount           = 0;
        $hasGeneratorComment = false;

        while ( false !== ( $line = \fgets( $stream ) ) ) {
            $lineCount++;

            if ( \str_starts_with( $line, '/*---' ) ) {
                $hasGeneratorComment = (bool) \trim( $line, " \n\r\t\v\0/*-" );

                break;
            }

            if ( $lineCount >= 15 || \ctype_alpha( $line[0] ) ) {
                break;
            }
        }

        \fclose( $stream );

        return $hasGeneratorComment;
    }
}

// protected function configurePreload( bool $override = false ) : self
// {
//     $this->createPhpFile(
//             'config/preload.php',
//             <<<'PHP'
//                 <?php
//
//                 declare(strict_types=1);
//
//                 if (\file_exists(\dirname(__DIR__).'/var/cache/prod/App_KernelProdContainer.preload.php')) {
//                     \opcache_compile_file(\dirname(__DIR__).'/var/cache/prod/App_KernelProdContainer.preload.php');
//                 }
//                 PHP,
//             $override,
//     );
//
//     return $this;
// }

// protected function generatePublicIndex( bool $override = false, string ...$comment ) : self
// {
//     $this->createPhpFile(
//                'public/index.php',
//             <<<PHP
//                 <?php
//
//                 declare(strict_types=1);
//
//                 require_once dirname( __DIR__ ).'/vendor/autoload_runtime.php';
//
//                 return static fn( array \$context ) => new \App\Kernel(
//                     (string) \$context['APP_ENV'],
//                     (bool) \$context['APP_DEBUG'],
//                 );
//                 PHP,
//                $override,
//             ...$comment,
//     );
//
//     return $this;
// }

// protected function generateAppKernel( bool $override = false, string ...$comment ) : self
// {
//     $this->createPhpFile(
//                'src/Kernel.php',
//             <<<PHP
//                 <?php
//
//                 declare(strict_types=1);
//
//                 namespace App;
//
//                 use Symfony\Bundle\FrameworkBundle\Kernel as FrameworkKernel;
//                 use Symfony\Component\HttpKernel\Kernel as HttpKernel;
//
//                 final class Kernel extends HttpKernel
//                 {
//                     use FrameworkKernel\MicroKernelTrait;
//
//                     public function hasContainer() : bool
//                     {
//                         return isset( \$this->container );
//                     }
//                 }
//                 PHP,
//                $override,
//             ...$comment,
//     );
//
//     return $this;
// }
